1. 通过数据库连接池提高性能，比较重要的两个参数:最大连接数和最小连接数，其创建的基本逻辑如下:
    1). 当当前连接数小于最小连接数，则新建连接
    2). 当池中有空闲连接则复用空闲连接
    3). 当小于最大连接数且无空闲连接，则创建新连接
    4). 当达到最大连接数，则等待旧连接可用，如果等待超时，则抛出错误
    5). 针对与Mysql，当数据库连接闲置超过wait_timeout,就会自动关闭连接
建议数据库连接池，最小在10左右，最大在20～30左右
可以通过启动一个线程来定时检测连接数判断数据库是否可用(执行select 1)
DBCP的testOnBorrow会在获取得连接之后先判断是否可用，可以在测试环境上使用，不建议在线上环境使用，因为影响性能

2. 通过线程池来并发处理业务(比如查询数据库),比如jdk的ThreadPoolExecutor，其两个重要参数：coreThreadCount和maxThreadCount，其创建的基本逻辑如下:
    1). 池中线程数小于coreThreadCount，新任务会创建新线程处理
    2). 池中线程数等于coreThreadCount，当新任务能够进入任务队列，则在队列中等待;当新任务不能进入任务队列，则创建新线程处理
    3). 池中线程数等于maxThreadCount,则无法进入任务队列，则按照设置的策略进行任务丢弃或者让提交线程自己执行等
注意:一定不要使用无界队列(线程池默认),会导致任务堆叠，最终宕机

3. 通过数据库的主从分离来提升系统的读性能
    1). 主从复制，在写入时只写主库，在读取时只读从库
    2). 一个主库最多挂3～5个从库
    3). 需要处理主从数据延迟的问题(核心是尽量不要从数据库中取查数据)(且要在性能和数据的强一致性上做权衡):
        1)). 使用缓存(数据和缓存在同步的时候，存在一致性的问题)
        2)). 查询主库(不建议使用，存在主库负载高的问题)
       建议把主从延迟作为监控指标，正常情况下应该在毫秒级别，若达到了秒级就要告警
    4). 数据库主从访问中间件:
        1)). 嵌入到应用程序内部直接访问数据库，如淘宝的TDDL，Sharding-JDBC
        2)). 通过代理层访问，如阿里的Corbar，mycat，360的Atlas，美团的DBProxy等，主要方式是改写SQL，然后发送到指定的数据源

*** 4核8G的云服务器上，Mysql可以支撑500TPS和10000QPS

4. 通过分库分表来解决单表过大的问题，目标是依照一定的策略将数据尽量平均分配到多个数据库节点或者多个表中， 通常有如下两种方式:
    1). 垂直拆分，按照业务类型拆分，专库专用
    2). 水平拆分，在垂直拆分的基础上，若单表依然过大，则进行水平拆分，通常有如下拆分策略:
        1)). 按照某一字段的hash值做拆分，优点是分布均匀，缺点是扩展困难
        2)). 按照某一个字段的区间来拆分，比如时间字段或者用户ID
    3). 分库分表导致的问题
        1)). 需要通过某一字段查询记录比较困难，解决方法是创建该字段到主键的冗余表（也可以分库分表)
        2)). 数据库的join,count,事务等难以实施，我们可以通过代码，缓存和分布式事务等进行处理
    4). 分库分表的建议:
        1)). 不要随意分库分表
        2)). 考虑使用nosql代替数据库进行存储
    5). 主键的生成(建议使用生成的ID作为数据库的主键):
        1)). 使用snowflake算法(或者变种算法生成主键)，有如下实施方式:
             嵌入到代码中，该算受机器ID和机器时间影响，该方法不建议
             通过单独服务来部署(其实效率也很高课题达到单例达到2w/s)
        2)). 不建议使用UUID作为主键，理由如下：
            1)). 不是单调底层，影响mysql的插入性能
            2)). 无业务含义，且没有排序，无法范围查找
            3)). 占用存储空间过大(影响主键索引，同时影响非主键索引)

5. 可以考虑使用Nosql来与关系数据库进行互补:
    1). 通常Nosql具有如下类型: 
        键值对:redis,leveldb
        文档: mongodb,couchdb
        列式存储:Hbase,Cassandra
    2). 大多数的Nosql都是使用基于LSM树的存储引擎(先写内存memtable，积累到一定规模则刷到文件中SSTable,当SSTable积累到一定程度，则进行文件的合并。而查询的时候也是从MEMTable到SSTable进行顺序查找)
    3). 通过提供辅助关系数据库存储大量数据，以及提供多维度的查询来对关系数据库进行补充
    4). 很多Nosql天生就支持数据分片，可以避免分库分表的操作

6. 数据库迁移策略(迁移其它支持主从的，如redis，都是可以这么操作的)(好处是可以回滚，缺点是时间周期长，应用需要改造):
    1). 双写
        1)). 将新库配置为旧库的从库来同步数据(若多库多表可以考虑第三方工具获取binlog的增量日志，比Canal工具)
        2)). 同时改造业务代码将数据同时写入旧库和新库(可异步写入新库),需要记录下写入辛苦失败的数据，以便之后补数据
        3)). 抽样检查部分数据，确保数据的一致性(还可以考虑通过校验脚本的方式来测试)
        4)). 通过灰度的方式切换流量到辛苦(10%~50%~100%)
   2). 级联同步(适合从本地机房迁移数据到云上)
        1)). 在云上准备一个新库，在本地准备一个备库
        2)). 将新库配置为旧库的从库，再将备库配置为新库的从库
        3)). 待3个库的写入一致之后，将数据库读流量切换到新库
        4)). 暂停应用的写入，将业务的写入流量切换到新库(要暂停应用的写入，需要安排在业务的低峰期)（回滚就是按照同样的切换手法，将流量切换到备库)
        
