1. 系统一体化的缺点:
    1). 当部署多个应用的时候，会导致与数据库的连接数增加，从而导致数据库连接超标(一个应用30个连接，Mysql最大可承受16384个连接(还要以具体的情况来调整))
    2). 会导致开发团队过大，交流成本提升
    3). 代码之间的耦合高，修改问题困难，测试回归难度大
    4). 系统运维困难，因为每次都要编译打包整个系统的代码

2. 微服务的优点:
    1). 将业务无关的公共服务抽取出来下沉层单独的服务
    2). 通过微服务拆分业务，每种服务单独连接自己的数据库，便于扩展，降低数据库压力

3. 微服务拆分原则:
    1). 单一服务的高内聚和低耦合
    2). 关注服务拆分的粒度，先粗略拆分，再逐渐细化
    3). 要避免影响产品的日常功能迭代
    3). 服务的接口定义要具备可扩展性，比如参数尽量适用对象，避免在修改参数的时候对接口进行修改

4. 微服务带来的问题和解决方案
    1). 使用注册中心来简化服务之间的调用
    2). 通过熔断，降级，限流，超时控制等方法来解决服务调用之间导致的慢请求的问题
    3). 通过分布式追踪来监控服务的调用链

5. 学习微服务的基本思路:
    1). 完成中间件的部署运行，建立感性认识
    2). 阅读文档中的基本原理和架构设计
    3). 阅读源码，加深理解

6. 如何提升服务之间的调用性能:
    1). 选择合适的网络模型，有针对性的调整网络参数优化网络传输性能(当前最常用的就是IO多路复用)
    2). 选择合适的序列化方式，提升封包和解包的性能(JSON，Thrift,Protobuf等,后两者需要引入IDL(接口描述语言))
        1)). 对性能要求不高，且占用带宽不大，建议适用JSON
        2)). 对性能要求高，可以使用Thrift或者Protobuf
        3)). 在一些存储的场景下，比如缓存存储的数据太多，可考虑使用Protobuf替换JSON

7. RPC调用的过程:
    1). 首先将调用的类名，方法名，参数名，参数值等信息序列化成二进制流
    2). 将二进制流通过网络发送给服务端
    3). 服务端反序列化二进制流，并通过动态代理的方式调用对应的方法得到返回值
    4). 服务端将返回值序列化，在通过网络发送给客户端
    5). 客户端对结果反序列化，并得到最终的调用结果

*** tcp_nodelay:防止服务器端在收到下一个ACK在返回这次的包，一般会在socket上开启该参数
    
8. 常用的注册中心: Zk, k8s的Etcd, 阿里的Nacos， Eureka等，其提供的基本功能包括:
    1). 服务地址的存储
    2). 当存储内容变化的时候，将变更的内容推送给客户端
    有了注册中心之后，对于服务的扩容，服务的调用，服务故障后自动摘除都会十分方便
    服务中心的服务状态管理是通过服务主动向注册中心发送心跳来实现的，当上一次心跳到到当前时间的间隔超时之后就认为服务不可用，之后从列表中将其删除掉
   使用注册中心的注意点：
       1). 预防注册中心在异常情况下摘除掉所有的服务，应该在摘除一定比例的服务之后向相关人员报警
       2). 当在注册中心注册的服务比较多的时候，当服务集体变更或者上线的时候，会导致大量的通知消息，所以要注意管理服务集群的大小

*** 静态代理：在编译时期做切面代码注入，如AspectJ(编译时间长)
*** 动态代理：在运行时期做切面代码注入，如Spring AOP(对性能有影响)

9. 分布式追踪：若自己实现，可以考虑在切面中实现日志打印，通过requestId和spanId来追踪服务的调用(若日志量过大，可以考虑通过requestId采样，最后通过es存储)
             若使用已有的中间件，可以考虑spring cloud的sleuth(上报消息)和zipkin(收集消息并通过界面展示调用链)结合的方式

10. 负载均衡:
    1). 服务器端负载均衡:LVS(在4层协议上)和Nginx(在7层协议上),LVS的性能更高，Nginx管得更细更灵活，对于大流量的场景，可以先经过LVS分流，再通过nginx进一步细分
    2). 客户端负载均衡：把负载均衡做在客户端中，在微服务中用的比较多
    3). 负载均衡策略: 轮询，带权重轮询，IP_hash和url_hash等
    4). 异常节点的摘除策略：如nginx，可以使用nginx_upstream_check_module,实际上就是通过健康检查接口开判断服务是否正常(需要服务提供指定的接口)

11. API网关
    入口API网关的作用:
        1). 对客户端提供统一的地址，并将用户的请求动态路由到不同的业务服务上
        2). 在API网关中植入服务治理策略，如熔断，降级，流量控制和分流等
        3). 可以实现客户端的认证和授权等
    出口API网关的作用：一般是对调用外部的API做统一的认证，授权和审计等
    当前开源的API网关,比如netflix的zuul,在2.0使用的是netty，通过I/O多路复用来处理接入的I/O请求；再如Kong，运行在Nginx上的lua程序，性能和运维的把控都较好;Tyk:Go语言实现的API网关
    可以考虑抽取独立的服务层做聚合服务，然后通过API网关->聚合服务->原子服务

12. ServiceMesh:当团队中各个服务使用的是不同的语言，导致无法使用注册中心和相关的负载均衡，熔断，限流，追踪等服务治理测量的时候，可以通过serviceMesh的方式来解决
    ServiceMesh的实现方式一般是通过sidecar的方式来处理服务治理，比较出名的是lstio项目，而将数据包无感知进行转发的主要方式是通过iptables
     其他的ServiceMesh有Linkerd和蚂蚁的SOFMesh
