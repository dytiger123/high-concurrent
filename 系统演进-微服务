1. 系统一体化的缺点:
    1). 当部署多个应用的时候，会导致与数据库的连接数增加，从而导致数据库连接超标(一个应用30个连接，Mysql最大可承受16384个连接(还要以具体的情况来调整))
    2). 会导致开发团队过大，交流成本提升
    3). 代码之间的耦合高，修改问题困难，测试回归难度大
    4). 系统运维困难，因为每次都要编译打包整个系统的代码

2. 微服务的优点:
    1). 将业务无关的公共服务抽取出来下沉层单独的服务
    2). 通过微服务拆分业务，每种服务单独连接自己的数据库，便于扩展，降低数据库压力

3. 微服务拆分原则:
    1). 单一服务的高内聚和低耦合
    2). 关注服务拆分的粒度，先粗略拆分，再逐渐细化
    3). 要避免影响产品的日常功能迭代
    3). 服务的接口定义要具备可扩展性，比如参数尽量适用对象，避免在修改参数的时候对接口进行修改

4. 微服务带来的问题和解决方案
    1). 使用注册中心来简化服务之间的调用
    2). 通过熔断，降级，限流，超时控制等方法来解决服务调用之间导致的慢请求的问题
    3). 通过分布式追踪来监控服务的调用链

5. 学习微服务的基本思路:
    1). 完成中间件的部署运行，建立感性认识
    2). 阅读文档中的基本原理和架构设计
    3). 阅读源码，加深理解

6. 如何提升服务之间的调用性能:
    1). 选择合适的网络模型，有针对性的调整网络参数优化网络传输性能(当前最常用的就是IO多路复用)
    2). 选择合适的序列化方式，提升封包和解包的性能(JSON，Thrift,Protobuf等,后两者需要引入IDL(接口描述语言))
        1)). 对性能要求不高，且占用带宽不大，建议适用JSON
        2)). 对性能要求高，可以使用Thrift或者Protobuf
        3)). 在一些存储的场景下，比如缓存存储的数据太多，可考虑使用Protobuf替换JSON

7. RPC调用的过程:
    1). 首先将调用的类名，方法名，参数名，参数值等信息序列化成二进制流
    2). 将二进制流通过网络发送给服务端
    3). 服务端反序列化二进制流，并通过动态代理的方式调用对应的方法得到返回值
    4). 服务端将返回值序列化，在通过网络发送给客户端
    5). 客户端对结果反序列化，并得到最终的调用结果

*** tcp_nodelay:防止服务器端在收到下一个ACK在返回这次的包，一般会在socket上开启该参数
    
8. 常用的注册中心: Zk, k8s的Etcd, 阿里的Nacos， Eureka等，其提供的基本功能包括:
    1). 服务地址的存储
    2). 当存储内容变化的时候，将变更的内容推送给客户端
