1. 谷歌针对分布式监控的4个黄金信号：延迟（响应时间)，通信量(吞吐量，QPS)，错误(系统发生的错误数量)，饱和度(服务或者资源达到上限的程度，如CPU/内存/磁盘使用率，数据库连接数等)

2. 数据采集的方式:
    1). 定时发送命令获取各种中间件提供的统计信息
    2). 通过JMX获取中间件的监控信息(比如kafka队列的堆积数等)
    3). 在代码中埋点 : 在后端和前端口可以考虑埋点，并经过一段时间积累之后发送给监控服务器
    4). 通过开源日志采集工具收集日志，并解析数据发送给监控服务器

3. 数据的存储和展示：
   1). es和kibana
   2). Spark和Storm,通过消息队列收集数据，并做解析，最后发送到时序数据库中(如influxDB,OpenTSDB,Graphite等),最后通过grafana进行展示

4. 报表:
    1). 访问趋势表:对接web服务器，展示服务的整体访问量，响应时间情况，错误数量，带宽等
    2). 性能报表:对接埋点信息，反映了被埋点资源的整体运行情况
    3). 资源报表：对接Agent采集的资源的运行情况

5. 用户端性能监控：通过在客户端或者浏览器上进行埋点，之后通过固定的接口定期发送给服务器端
   发送的数据应该加密，客户端请求服务器端的公钥，之后随机生成公钥和私钥，再通过服务器端的公钥加密私钥，通过http的header发送给服务器端，服务器端通过私钥解密获取到私钥，用于之后的消息的解密
   需要收集的客户端数据:
    1). 一次网络请求的各个阶段的耗时：等待时间,DNS时间，TCP握手时间，SSL时间，发送时间，首包时间，包接收时间等
    2). 异常信息:登录失败，下单失败。。。各种失败
    3). 其它的根据项目具体分析

压力测试 ： 
   1). 注意点:最好使用线上环境和线上数据做测试；使用线上的浏览做测试；不要从一台服务器发起流量，而是要尽量发到不同机房的机器上，确保压力测试结果的真实性
   2). 不能只针对某一个和性模块做压测，而是要将接入层，后端服务，数据库，缓存，消息队列和中间件以及依赖的第三方服务及资源都纳入测试的目标，即全链路压测

压测平台的搭建:
    1). 压测数据的产生:将高峰时期的数据拷贝一份，经过数据清洗之后村村再Hbase，ES这些Nosql中
        一般有如下拷贝流量的方式: 
        1)). 拷贝Nginx的日志
        2)). 使用开源工具，比如GoReplay(劫持本纪某一端口流量，并记录在文件中
       之后需要对拷贝的流量染色，加上header标记之后，再回写到流量工厂中
    2). 数据隔离: 通过对系统改造来对压测流量和正式流量进行隔离，比如对不能进行压测的服务或者组件进行Mock或者特殊处理
    3).压力测试的实施:
        先设立一个压测目标：比如整体QPS达到20W/s再按照一定的步长逐渐增加
        设定性能阈值，比如CPU设置成60%~70%,系统的平均响应时间上限为1s等，当性能达到阈值的时候，流量监控组可以及时发现，并让开发和运维排查性能瓶颈，之后继续执行压测
        
配置文件：
    1). 考虑把配置文件存储在外部标准的目录中，并通过git管理，待使用时，直接拉取git下的配置文件即可
    2). 常用的配置中心：Apollo(携程), Disconf(百度), QConf(360), Spring Cloud Config
        配置中心的作用：配置项的存储和读取
        配置文件更新的方式: 
           1)). 客户端定时轮询(通过计算MD5来判断配置是否存在变更)
           2)). 通过保存于客户端的长连接，在服务器端的配置文件发送改变的时候，自动推送给客户端
       配置中心的高可用: 在客户端上配置缓存(内存中和本地),以便在配置中心挂了的时候，应用程序不受到影响

熔断：通过有限状态机实现，3种状态:
    关闭：半打开状态，若请求能够达到后端，则切换到关闭，否着切换到打开
    半打开：当打开状态超时，状态切换为半打开
    打开：失败次数达到一定阈值，从关闭切换打开(调用成功会重置失败次数)

降级：
    熔断降级：通过熔断的方式实现降级
    开关降级：通过开关的方式实现降级，比如通过配置中心设定开关(可不重启)，需要于先在代码中埋下开关

限流：核心服务无法降级，要保证其稳定，只能限流
    固定/划动时间窗口算法：前者时固定时间窗口只能有多少访问，后者时把固定时间再细分层小的时间窗口，随时间的移动来移动小窗口，都不能解决短时间内集中访问的问题
    漏桶算法：流量会进入并暂存到漏桶里，漏桶的出口会按照固定速率将流量漏出到接收端（即通过消息队列的方式进行限流，消息队列流量溢出，之后的请求就拒绝)
    令牌桶算法：每隔1/N的时间往桶里方一个令牌，在处理请求之前，要先从桶里获取到令牌。当桶里的令牌达到上限，就不能再继续新增令牌（比如guava的限流方案)(可以预先再令牌桶里放一定量的令牌)
