1. 缓存：存储数据的组件，作用是让数据更快的返回，不一定是内存，也可以是顺序读写的磁盘

2. 缓存分类:
    1)). 静态缓存：静态页面，图片，静态文件(通过CDN，Nginx等部署)
    2)). 分布式缓存: redis, memcached
    3)). 热点本地缓存: HashMap, Guava cache, EHcache，它们和应用程序部署在同一个进程中)

3. 缓存的缺点:
    1). 适合读多写少的场景
    2). 增加系统复杂度，并存在数据不一致的风险
    3). 一般会限制于内存的大小
    4). 增加运维成本

4. 缓存读写问题讨论(缓存+数据库):
    1). 在不上锁的场景下，最优的写缓存的方式是:更新数据库，之后删除缓存(因为删除缓存非常快，所以导致数据不一致的情况会很低)
    2). 当缓存命中率有严格要求的时候，有两种方案:
        1)). 在更新缓存前加一个分布式锁
        2)). 更新数据库的时候更新缓存，并为缓存添加较短的过期时间

5. 通过缓存写和通过缓存读(为防止缓存数据丢失，可以采用主备的方式加强缓存的高可用性):
   1). 通过缓存写即先写缓存，若缓存中有值，则更新缓存，之后通过缓存更新到数据库；若缓存中无值，则直接写数据库
   2). 通过缓存读即先查缓存，如果存在直接返回，如果不存在则从数据库读取到缓存，再从缓存中读取

6. 在高并发(比如QPS=10000)的电商系统中，核心服务的缓存的命中率必须在99%以上（非核心的也要在90%以上），否则可能对数据库造成极大的冲击
   1). 缓存穿透:在缓存中没有查询到数据，从而不得不到数据库中查找数据，其解决方案有:
       回种空值，并设置较短的失效时间(但是会浪费内存)
       布隆过滤器，缺点有对判断元素的存在不一定准确(所以我们都是判断元素不存在的场景)；二是不支持删除元素，可以通过在数组中计数来解决该问题
   2). 对于某个热点数据，当其缓存失效的时候，会导致大量的请求到达数据库，从而造成缓存击穿，解决方案有：
       通过异步线程在缓存失效之后从数据库加载数据到缓存，此时所有请求缓存的数据都直接返回
       在缓存穿透的时候，加分布式锁再从数据库中加载数据到缓存

7. 缓存的高可用方案:
   1). 客户端方案:写入数据的时候，需要将缓存的数据分散到多个节点(hash或者一致性hash)；读取数据的时候，可以利用主从或者多副本的方式来做容错,比较典型的缓存是memcached
   2). 中间代理层方案:所有缓存的读写都是通过代理层，代理层的作用是负责读写请求的路由，并内值高可用逻辑，比如Fackbook的Mcrouter,Twitter的Twemproxy和豌豆夹的Codis
   3). 服务端方案:当主节点挂了之后，自动将从节点提升为主节点，保证整体集群的可用性，比如redis的sentinel方案

8. 静态资源的缓存:
   1). 当访问量不大的时候，可以将静态资源通过nginx等web服务器进行缓存
   2). 当访问量很大，而且涉及道不同的地域访问的时候，需要考虑通过CDN进行缓存
       1)). 将域名映射到CDN提供的域名或者IP地址上，如下是域名解析流程 : 先从本地hosts文件中查找，再从Local DNS查询，再从DNS顶级域名从上往下查找，最终解析到IP地址
       2)). 通过GSLB(全局负载均衡)进行负载均衡和确保用户获取到最近CDN上的静态文件:我们通过CDN厂商的接口将静态资源输入到某个CDN节点上，再由CDN内部将资源分散同步到每个CDN节点，用户会首先从CDN节点上获取数据，当获取不到数据的时候，会从原站获取数据

9. 数据迁移的缓存预热
   1). 若是redis，设置主从同步即可
   2). 若是memcached这种缓存，则需要在新缓存中查询不到的时候，从旧缓存中查询对应数据，回种到云上的副本组
       还可以在本地数据写入的时候，异步写入到云上的mc节点，之后通过灰度的方式检查云上节点的缓存命中率，当达到90%以上的时候，就完全切换到云上缓存节点(如何检查缓存命中率?)
